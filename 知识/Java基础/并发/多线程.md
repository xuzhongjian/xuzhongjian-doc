# 多线程 #

## 线程和进程 ##

### 线程 ###

### 进程 ###

### 使用多线程的原因 ###

1. 更多的处理器核心数量，更加适合多线程处理。使用单线程是对资源的浪费。

2. 数据一致性不强的操作，可以使用多线程来处理，缩响应时间。

## 线程的创建 ##

1. 新建一个类，继承Thread类，重写其中的run方法。然后实例化这个类，直接使用这个类的start方法，即可启动这个线程。

    ```java
    package com.xuzhongjian.thread.model;

    /**
    * @author zjxu97 at 1/2/21 11:04 AM
    */
    public class TestThread extends Thread {
        @Override
        public void run() {
            super.run();
        }
    }
    ```

    ```java
    package com.xuzhongjian.thread;

    import com.xuzhongjian.thread.model.TestThread;

    /**
    * @author zjxu97 at 1/3/21 1:11 AM
    */
    public class Main {
        public static void main(String[] args) {
            TestThread thread = new TestThread();
            System.out.println("this is main thread");
            thread.start();
        }
    }
    ```

2. 实现runnable接口，实现其中的run方法，将这个runnable接口的实现作为Thread类的构造方法的参数，对Thread类进行实例化，调用Thread对象的start方法。

    ```java
    package com.xuzhongjian.thread;

    /**
    * @author zjxu97 at 1/2/21 11:00 AM
    */
    public class Main {
        public static void main(String[] args) {
            Thread thread = new Thread(() -> {
                System.out.println("this is a new thread");
            });
            System.out.println("this is main thread");
            thread.start();
        }
    }
    ```

3. 实现callable接口，将实现的callable接口的实现作为FeatureTask类的构造方法，构造一个FeatureTask类的实现，然后将这个实现作为Thread类的构造方法的，然后启动这个线程。

```java
package com.xuzhongjian.thread.model;

import java.util.concurrent.FutureTask;

/**
 * @author zjxu97 at 1/3/21 1:13 AM
 */
public class FutureTaskMain {
    public static void main(String[] args) {
        try {
            FutureTask<String> futureTask = new FutureTask<>(() -> {
                Thread.sleep(100);
                return "futureTask done";
            });

            Thread thread = new Thread(futureTask);
            thread.start();
            while (!futureTask.isDone()) {
                Thread.sleep(10);
                System.out.println("main waiting");
            }
            System.out.println(futureTask.get());
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
}
```

```java
// sout:
main waiting
main waiting
main waiting
main waiting
main waiting
main waiting
main waiting
main waiting
main waiting
futureTask done
```

## 线程的状态 ##

![Java线程状态表](../imgs/thread_status.jpg)

![线程转化图](../imgs/thread_tans.jpg)

1. 初始化

2. 就绪

3. 运行中
   - 在Java线程中，其中就绪和运行中统一被称为可运行状态。

4. 等待

5. 计时等待

6. 阻塞

7. 终止

## 中断 ##

关于中断的三个方法

1. interrupt()
    - Thread 类的实例方法：将某个线程标记成中断中断状态。
2. interrupted()
    - Thread 类的静态方法：重置调用该方法的线程的中断状态。
3. isInterrupted()
    - Thread 类的实例方法：判断线程有没有中断状态。

“许多声明抛出InterruptedException的方法（例如Thread.sleep(long millis)方法）这些方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。”

Excerpt From: 方腾飞,魏鹏,程晓明 著. “Java并发编程的艺术 (Java核心技术系列).” Apple Books.

## 线程间通信 ##

如果每个线程都单独的运行，线程和线程之间没有相互配合和沟通，这样的多线程是价值是很低的。
