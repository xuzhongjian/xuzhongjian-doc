# JVM #

### JVM的内存结构。 ###

堆、虚拟机栈、本地方法栈、程序计数器、方法区

+ 公有的
  + 堆
  + 方法区
+ 线程私有的
  + 虚拟机栈
  + 本地方法栈
  + 程序计数器

### JVM方法栈的工作过程，方法栈和本地方法栈有什么区别。 ###

虚拟机栈和本地方法栈的区别在于，一个是用来执行Java方法的，一个是用来执行native方法的。

当开启一个线程之后，jvm就会分配一个方法栈、一个本地方法栈和一个程序计数器给这个新的线程私有。

方法栈的工作过程：线程的运行可以看成是方法的执行的过程。方法栈中的栈帧就是一个一个的方法。方法开始执行就是栈帧push，方法执行完成就是pop。程序计数器用来记录方法执行的行数。

### JVM的栈中引用如何和堆中的对象产生关联。 ###

对象生成时，产生的首地址存储在栈中，这样两者就关联起来了。

如

```java
Student s = new Student();
```

s放在栈中，new Student()是放在堆中。这里是通过对象地址引用s（指针）指向new Student()实列。

### 可以了解一下逃逸分析技术。 ###

+ 方法逃逸：当一个对象在方法中被定义后，因为可能被外部方法引用，比如作为调用参数被传递到其他的方法里。
+ 线程逃逸：当一个对象在方法中被定义后，可能被外部线程访问到，比如给类变量或者在其他线程中访问的实例变量。
+ 栈上分配：就是把**没发生逃逸的对象**，在栈分配空间。（一般对象分配空间是在堆）
+ jvm根据对象是否发生逃逸，会分配到不同（堆或栈）的存储空间。如果对象发生逃逸，那会分配到堆中。

### GC的常见算法 ###

+ 标记清除
  + 产生内存碎片
  + 标记和清除的效率都不高
+ 标记整理
  + 不会产生内存碎片
  + 移动的过程效率很低
+ 复制
  + 不产生内存碎片
  + 会损失部分内存
  + 在商用的jvm中，对经典的复制算法有所改变，将其划分为1:1:8 的三块（to:from:eden）

### CMS的各个阶段哪两个是Stop the world的？ ###

cms的四个回收阶段

1. 初始标记：stw 根据找到 GC root 关联的对象。
2. 并发标记：从与GC root开始，相关联的对象开始标记，所有的使用中的对象，从而找出垃圾对象。
3. 重新标记：stw 为了修正并发标记期间因用户程序继续运行而导致标记产品变动的那一部分对象的标记记录。
4. 并发清除：标记清除法

cms本质上是标记清除算法，只是对标记过程存在一些改变。cms存在的缺点是：

1. 吞吐量低（吞吐量 = 有效逻辑的时间 / cpu所有时时间）
2. 并发清除过程中存在浮动垃圾
3. 标记清除算法本质上存在空间碎片

### G1的垃圾回收过程，G1的优势。 ###

https://www.cnblogs.com/yufengzhang/p/10571081.html

1. 标记整理
2. 

和cms类似，只是将分代的收集变成了分块的收集。在收集的时候计算收集每一块的收益，按照收益最高的进行回收。

**最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。**

### 双亲委派模型的过程以及优势。 ###

一个类的加载，首先会将类的加载请求转发到它的父级加载器，只有父加载器无法加载的时候，才会尝试自行加载。

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。因此，使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处：**类随着它的类加载器一起具备了一种带有优先级的层次关系**。保证了Java的核心基础类按照层次得到了统一。

### 对象什么时候进入老年代？ ###

1. 大对象会直接进入老年代
2. 长期存活的对象进入老年代
3. 动态年龄判断
  + 如果同一个年龄的对象占到了survivor区域的总空间的一半，那么大于或等于这个年龄的对象都进入老年代。
4. 空间分配担保
  + 如果大量对象在 Minor GC 后仍然存活，导致 Survivor 空间不够用，就会通过分配担保机制，将多出来的对象提前转到老年代。

### 什么是内存溢出， 内存泄露？ 他们的区别是什么？ ###
+ 内存溢出: 在申请内存的时候，没有足够的内存空间供申请使用。
+ 内存泄漏: 程序在申请了内存之后，没有办法释放已经申请的内存。

大量的内存泄漏问题的累积，会导致内存溢出的产生。

### 引起类加载操作的行为有哪些？ ###
1. new 这个对象的时候
2. 调用这个类的静态方法
3. 使用 get 或者 set 这个类的静态字段的时候
3. 使用 java.lang.reflect 反射，对这个类进行反射的时候
4. 在初始化子类，但是父类还没有初始化的时候
不会调用这个类的加载的情况是：
1. 通过子类调用父类的静态字段，子类不会加载
2. 类的数组，在进行数组的定义的时候
3. 通过类调用静态字段，这些静态字段存储在常量池中的时候

### Full GC 、 Major GC 、Minor GC 之间区别？ ###
+ Minor GC: 对年轻代进行GC
+ Major GC: 对老年代进行GC
+ Full GC: Full GC 是清理整个堆空间，包括年轻代和老年代

https://zhuanlan.zhihu.com/p/86875263

### 什么时候触发Minor GC？ ###

当 eden 区的空间不足的时候。

### 什么时候触发Major GC？ ###

1. 对于一个大对象，我们会首先在Eden 尝试创建，如果创建不了，就会触发Minor GC 
2. 随后继续尝试在eden区存放，发现仍然放不下
3. 尝试直接进入老年代，老年代也放不下
4. 触发 Major GC 清理老年代的空间
5. 放的下 成功
6. 放不下 OOM

### 什么时候触发 Full GC ？ ###

+ 老年代空间不足
+ 方法区（持久代）空间不足
+ 显示调用System.gc

### 什么情况下会出现栈溢出 ###

方法执行的时候所push进的栈帧超过了栈的最大深度，这个最大深度是可以由JVM参数配置的。

### 说一下强引用、软引用、弱引用、虚引用以及他们之间和 gc 的关系 ###

强软弱虚

1. 强引用：基于可达性分析法进行回收
2. 软引用：空间不足则一定会被回收
3. 弱引用：下次GC一定会被回收
4. 虚引用：被虚引用的对象被回收之后会收到一个通知

### Eden 和 Survivor 的比例分配是什么情况？为什么？ ###

eden : to survivor : from survivor  = 8 : 1 : 1

对象出生在eden区，大部分的eden区新出生的对象都活不过一次gc。

### 什么是分布式垃圾回收（DGC）？它是如何工作的？ ###

https://blog.csdn.net/wodewutai17quiet/article/details/53550158

### 在 Java 中，对象什么时候可以被垃圾回收？ ###

引用计数法 和 可达性分析法。